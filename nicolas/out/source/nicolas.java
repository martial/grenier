/* autogenerated by Processing revision 1286 on 2023-04-20 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import oscP5.*;
import netP5.*;
import java.io.UnsupportedEncodingException;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class nicolas extends PApplet {





OscP5 oscP5;
NetAddress sender;

PFont myFont;
String receivedPrompt = "";
String receivedChat = "";

float maxWidth = 700;
float padding = 20;

BackgroundColorFader fader;

 public void setup() 
{
    /* size commented out by preprocessor */;

    // Initialize oscP5 and listen on port 8000
    oscP5 = new OscP5(this, 8000);
    sender = new NetAddress("127.0.0.1", 8000);
    fader = new BackgroundColorFader(1000);  // Create an instance of BackgroundColorFader with a fade duration of 5 seconds
    fader.changeColor(152, 251, 152);
    /* smooth commented out by preprocessor */;
    myFont = loadFont("Cogito-Regular-22.vlw");
    textFont(myFont);
}

 public void draw() 
{
    fader.update();
    fill(0);
    textAlign(LEFT, TOP);

    // Display the received prompt text on the screen
    String wrappedText = wordWrap("Prompt : "+receivedPrompt, maxWidth);
    text(wrappedText, padding, padding);

    float y = getStringHeight("Prompt : "+receivedPrompt, maxWidth)+1;

    // Display the received chat text on the screen
    wrappedText = wordWrap("Chat : "+receivedChat, maxWidth);
    text(wrappedText, padding, padding+(y*20));
}

// This method is called when an OSC message is received
 public void oscEvent(OscMessage msg)
{
    if (msg.checkAddrPattern("/prompt/")) {
      byte[] receivedBytes = msg.get(0).blobValue();
      try {
        receivedPrompt = new String(receivedBytes, "UTF-8");
      }
      catch (UnsupportedEncodingException e) {
        println("UnsupportedEncodingException: " + e.getMessage());
      }
    }
  
    if (msg.checkAddrPattern("/chat/")) {
      //receivedChat = msg.get(0).stringValue();
      //println(receivedText);
      byte[] receivedBytes = msg.get(0).blobValue();
      try {
        receivedChat = new String(receivedBytes, "UTF-8");
      }
      catch (UnsupportedEncodingException e) {
        println("UnsupportedEncodingException: " + e.getMessage());
      }
    }

    if (msg.checkAddrPattern("/status/")) {
      String status = msg.get(0).stringValue();
      println(status);
      if (status.equals("processing")) {
        fader.changeColor( 216, 191, 216);  // Change the background color to a random color when the mouse is pressed
      }
      if (status.equals("listening")) {
        fader.changeColor(152, 251, 152);  // Change the background color to a random color when the mouse is pressed
      }
    }
}

 public float getStringHeight(String inputText, float maxWidth) 
{  
  float h = 0;
  String[] words = inputText.split(" ");
  String outputText = "";
  String currentLine = "";

  for (int i = 0; i < words.length; i++) 
  {
      String currentWord = words[i] + " ";
      float currentLineWidth = textWidth(currentLine + currentWord);

      if (currentLineWidth < maxWidth) {
        currentLine += currentWord;
      } else {
        outputText += currentLine + "\n";
        currentLine = currentWord;
        h++;
      }
  }

  outputText += currentLine;
  h++;

  return h;
}


// Word wrap function
 public String wordWrap(String inputText, float maxWidth) 
{
  String[] words = inputText.split(" ");
  String outputText = "";
  String currentLine = "";

  for (int i = 0; i < words.length; i++) {
    String currentWord = words[i] + " ";
    float currentLineWidth = textWidth(currentLine + currentWord);

    if (currentLineWidth < maxWidth) {
      currentLine += currentWord;
    } else {
      outputText += currentLine + "\n";
      currentLine = currentWord;
    }
  }

  outputText += currentLine;
  return outputText;
}

 public void keyPressed() 
{   
  fader.changeColor(random(255), random(255), random(255));
}
class BackgroundColorFader 
{
  int startColor, endColor, currentColor;
  int fadeDuration, startTime;
  boolean changeLuminosity;

  BackgroundColorFader(int fadeDuration) {
    this.fadeDuration = fadeDuration;
    this.startTime = millis();
    this.changeLuminosity = false;
  }

   public void changeColor(float r, float g, float b) {
    startColor = currentColor;
    endColor = color(r, g, b);
    startTime = millis();
    println(r);
  }

  // void changeColor(color c) {
  //   startColor = currentColor;
  //   endColor = c;
  //   startTime = millis();
  //   println(r);
  // }

   public void update() {
    float t = (float) (millis() - startTime) / fadeDuration;
    t = constrain(t, 0, 1);
    currentColor = lerpColor(startColor, endColor, t);
    if (changeLuminosity) {
      float lum = brightness(currentColor);
      float newLum = lum + 20 * cos(PI * t);
      currentColor = color(hue(currentColor), saturation(currentColor), constrain(newLum, 0, 100));
    }
    background(currentColor);
  }
}


  public void settings() { size(800, 600);
smooth(); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "nicolas" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
